<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EBD IPKVM Web Client (Prototype)</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        --video-width: 1024px;
        --video-height: 684px;
        --panel-height: 760px;
      }
      html,
      body {
        height: 100%;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0e1117;
        color: #f5f5f5;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 12px 20px;
        border-bottom: 1px solid #1f2430;
      }
      header h1 {
        font-size: 1.2rem;
        margin: 0 0 4px;
      }
      main {
        display: grid;
        grid-template-columns: calc(var(--video-width) + 60px) 320px;
        gap: 16px;
        padding: 12px 20px 16px;
        flex: 1;
        min-height: 0;
        max-width: 100%;
        margin: 0 auto;
        justify-content: center;
        align-items: start;
      }
      .video-column {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .panel.video-panel {
        width: 100%;
        min-height: var(--panel-height);
        display: flex;
        flex-direction: column;
        align-items: center;
        background: linear-gradient(180deg, #d8d3ca 0%, #cdc6bc 100%);
        border: 1px solid #b8b0a2;
        border-radius: 14px;
        padding: 14px 28px 44px;
        box-shadow: inset 0 1px 1px #f1ece4, inset 0 -2px 3px #b9b2a8;
      }
      .panel {
        background: #151a23;
        border: 1px solid #1f2430;
        border-radius: 12px;
        padding: 12px;
      }
      .controls {
        width: 100%;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 8px;
      }
      .checkbox-control {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: #fff;
        font-size: 0.85rem;
        margin-left: 4px;
      }
      button {
        border: none;
        border-radius: 8px;
        padding: 8px 12px;
        font-weight: 600;
        cursor: pointer;
      }
      button.primary {
        background: #3b82f6;
        color: #fff;
      }
      button.secondary {
        background: #2f3645;
        color: #fff;
      }
      .status {
        font-size: 0.85rem;
        color: #9aa4b2;
        margin: 4px 0 0;
      }
      .video-canvas {
        width: var(--video-width);
        height: var(--video-height);
        border-radius: 3px;
        background: #0b0f17;
        border: 1px solid #3f3f3f;
        box-shadow: inset 0 0 0 6px #efebe3;
        display: grid;
        place-items: center;
        color: #5f6b7a;
        font-size: 0.9rem;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      .console {
        display: flex;
        flex-direction: column;
        gap: 8px;
        height: var(--panel-height);
        align-self: start;
        margin-left: 10px;
      }
      .console h2 {
        margin: 0;
        font-size: 1rem;
      }
      .console-log {
        flex: 1;
        background: #0b0f17;
        border-radius: 8px;
        border: 1px solid #2a3242;
        padding: 10px;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.8rem;
        overflow-y: auto;
        white-space: pre-wrap;
      }
      .console-input {
        display: flex;
        gap: 8px;
      }
      .console-input input {
        flex: 1;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #2a3242;
        background: #0b0f17;
        color: #fff;
      }
      .video-footer {
        width: 100%;
        margin-top: 10px;
        min-height: 14px;
        display: flex;
        justify-content: flex-end;
      }
      .power-led {
        width: 9px;
        height: 9px;
        border-radius: 50%;
        border: 1px solid #707067;
        background: #2e2e2e;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3) inset;
        transition: background 120ms ease, box-shadow 120ms ease;
      }
      .power-led.on {
        background: #55f07c;
        box-shadow: 0 0 4px #55f07c, 0 0 8px rgba(85, 240, 124, 0.85);
      }
      .note {
        font-size: 0.8rem;
        color: #fff;
        margin: 0;
        max-width: var(--video-width);
      }
      .note strong {
        color: #9dd8ff;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>EBD IPKVM Web Client</h1>
      <p class="status" id="session-status">Status: idle (single-session, single-client)</p>
    </header>
    <main>
      <div class="video-column">
        <section class="panel video-panel">
          <div class="controls">
            <button class="primary" id="start-btn">Start Capture / Boot Mac</button>
            <button class="secondary" id="stop-btn">Stop</button>
            <label class="checkbox-control" for="boot-rom-disk">
              <input id="boot-rom-disk" type="checkbox" />
              Boot for ROM disk
            </label>
          </div>
          <canvas class="video-canvas" id="video-canvas" width="512" height="342">
            Video stream placeholder (512 × 342 source, 2× display)
          </canvas>
          <div class="video-footer">
            <div class="power-led" id="power-led" aria-label="Power LED"></div>
          </div>
        </section>
        <p class="note">
          The backend stays idle until you start a session. Only one browser session can own the
          Pico + CDC0 control connections at a time.
        </p>
        <p class="note">
          <strong>Mouse capture:</strong> click the video canvas to lock the pointer and stream
          relative motion + left-click state to the ADB Arduino bridge. Right-click to
          release pointer lock before keyboard passthrough testing.
        </p>
      </div>
      <section class="panel console">
        <h2>CDC0 Live Console</h2>
        <div class="console-log" id="console-log"></div>
        <div class="console-input">
          <input id="console-input" type="text" placeholder="Type and press Enter..." />
        </div>
      </section>
    </main>
    <script>
      const consoleLog = document.getElementById("console-log");
      const sessionStatus = document.getElementById("session-status");
      const input = document.getElementById("console-input");
      const startBtn = document.getElementById("start-btn");
      const stopBtn = document.getElementById("stop-btn");
      const bootRomDiskCheckbox = document.getElementById("boot-rom-disk");
      const canvas = document.getElementById("video-canvas");
      const powerLed = document.getElementById("power-led");
      const ctx = canvas.getContext("2d", { alpha: false });

      const WIDTH = 512;
      const HEIGHT = 342;
      const LINE_BYTES = 64;
      const RLE_FLAG = 0x8000;
      const LEN_MASK = 0x7fff;
      const MOUSE_SENSITIVITY = 0.75;
      const MOUSE_MAX_DELTA_PER_PACKET = 24;
      const MOD_CMD = 1;
      const MOD_OPT = 2;
      const MOD_SHIFT = 4;
      const MOD_CONTROL = 8;
      const MOD_CAPS = 32;
      const MOD_DELETE = 64;
      const BROWSER_CODE_TO_MAC_KEYCODE = {
        KeyA: 0x00, KeyS: 0x01, KeyD: 0x02, KeyF: 0x03, KeyH: 0x04, KeyG: 0x05,
        KeyZ: 0x06, KeyX: 0x07, KeyC: 0x08, KeyV: 0x09, KeyB: 0x0b, KeyQ: 0x0c,
        KeyW: 0x0d, KeyE: 0x0e, KeyR: 0x0f, KeyY: 0x10, KeyT: 0x11, Digit1: 0x12,
        Digit2: 0x13, Digit3: 0x14, Digit4: 0x15, Digit6: 0x16, Digit5: 0x17,
        Equal: 0x18, Digit9: 0x19, Digit7: 0x1a, Minus: 0x1b, Digit8: 0x1c,
        Digit0: 0x1d, BracketRight: 0x1e, KeyO: 0x1f, KeyU: 0x20, BracketLeft: 0x21,
        KeyI: 0x22, KeyP: 0x23, Enter: 0x24, KeyL: 0x25, KeyJ: 0x26, Quote: 0x27,
        KeyK: 0x28, Semicolon: 0x29, Backslash: 0x2a, Comma: 0x2b, Slash: 0x2c,
        KeyN: 0x2d, KeyM: 0x2e, Period: 0x2f, Tab: 0x30, Space: 0x31, Backquote: 0x32,
        Backspace: 0x33, Escape: 0x35, MetaLeft: 0x37, ShiftLeft: 0x38, CapsLock: 0x39,
        AltLeft: 0x3a, ControlLeft: 0x3b, ShiftRight: 0x3c, AltRight: 0x3d,
        ControlRight: 0x3e, ArrowLeft: 0x3b, ArrowRight: 0x3c, ArrowDown: 0x3d,
        ArrowUp: 0x3e, NumpadDecimal: 0x41, NumpadMultiply: 0x43, NumpadAdd: 0x45,
        NumpadClear: 0x47, NumpadDivide: 0x4b, NumpadEnter: 0x4c, NumpadSubtract: 0x4e,
        NumpadEquals: 0x51, Numpad0: 0x52, Numpad1: 0x53, Numpad2: 0x54, Numpad3: 0x55,
        Numpad4: 0x56, Numpad5: 0x57, Numpad6: 0x58, Numpad7: 0x59, Numpad8: 0x5b,
        Numpad9: 0x5c, F5: 0x60, F6: 0x61, F7: 0x62, F3: 0x63, F8: 0x64, F9: 0x65,
        F11: 0x67, F13: 0x69, F14: 0x6b, F10: 0x6d, F12: 0x6f, F15: 0x71, Insert: 0x72,
        Home: 0x73, PageUp: 0x74, Delete: 0x75, End: 0x77, PageDown: 0x79, F1: 0x7a,
        F2: 0x78, F4: 0x76
      };

      ctx.imageSmoothingEnabled = false;

      let currentFrameId = null;
      let lineCount = 0;
      let lineBuffer = new Uint8Array(LINE_BYTES * HEIGHT);
      let renderBuffer = new Uint8Array(LINE_BYTES * HEIGHT);
      let lineSeen = new Uint8Array(HEIGHT);
      let frameReady = false;
      let renderQueued = false;
      const imageData = ctx.createImageData(WIDTH, HEIGHT);
      let pointerLocked = false;
      let mouseDown = false;
      let pendingDeltaX = 0;
      let pendingDeltaY = 0;
      let mouseSendQueued = false;
      let lastSentMouseDown = false;
      let virtualPointerX = WIDTH / 2;
      let virtualPointerY = HEIGHT / 2;

      const clamp = (value, minValue, maxValue) => Math.min(maxValue, Math.max(minValue, value));

      const clearVideoCanvas = () => {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      };

      const resetFrameBuffer = () => {
        lineBuffer.fill(0);
        lineSeen.fill(0);
        lineCount = 0;
      };

      const resetVideoState = () => {
        resetFrameBuffer();
        renderBuffer.fill(0);
        frameReady = false;
        currentFrameId = null;
      };

      const decodeRleLine = (payload) => {
        if (payload.length % 2 !== 0) {
          return null;
        }
        const output = new Uint8Array(LINE_BYTES);
        let outIndex = 0;
        for (let i = 0; i < payload.length; i += 2) {
          const count = payload[i];
          const value = payload[i + 1];
          if (count === 0) {
            return null;
          }
          if (outIndex + count > LINE_BYTES) {
            return null;
          }
          output.fill(value, outIndex, outIndex + count);
          outIndex += count;
        }
        if (outIndex !== LINE_BYTES) {
          return null;
        }
        return output;
      };

      const renderFrame = () => {
        const pixels = imageData.data;
        for (let y = 0; y < HEIGHT; y += 1) {
          const rowStart = y * LINE_BYTES;
          for (let xByte = 0; xByte < LINE_BYTES; xByte += 1) {
            const byte = renderBuffer[rowStart + xByte];
            for (let bit = 7; bit >= 0; bit -= 1) {
              const on = (byte >> bit) & 1;
              const value = on ? 255 : 0;
              const x = xByte * 8 + (7 - bit);
              const pixelIndex = (y * WIDTH + x) * 4;
              pixels[pixelIndex] = value;
              pixels[pixelIndex + 1] = value;
              pixels[pixelIndex + 2] = value;
              pixels[pixelIndex + 3] = 255;
            }
          }
        }
        ctx.putImageData(imageData, 0, 0);
      };

      const queueRender = () => {
        if (renderQueued) {
          return;
        }
        renderQueued = true;
        requestAnimationFrame(() => {
          renderQueued = false;
          if (frameReady) {
            renderFrame();
            frameReady = false;
          }
        });
      };

      const appendLog = (message) => {
        const line = document.createElement("div");
        line.textContent = message;
        consoleLog.appendChild(line);
        consoleLog.scrollTop = consoleLog.scrollHeight;
      };

      const fallbackId = () => `browser-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const ownerId = typeof crypto !== "undefined" && crypto.randomUUID
        ? `browser-${crypto.randomUUID()}`
        : fallbackId();

      const setPowerLed = (isOn) => {
        powerLed.classList.toggle("on", isOn);
      };

      const getModifierKeys = (event) => {
        let keys = 0;
        if (event.metaKey) keys |= MOD_CMD;
        if (event.altKey) keys |= MOD_OPT;
        if (event.shiftKey) keys |= MOD_SHIFT;
        if (event.ctrlKey) keys |= MOD_CONTROL;
        if (event.getModifierState && event.getModifierState("CapsLock")) keys |= MOD_CAPS;
        if (event.code === "Delete") keys |= MOD_DELETE;
        return keys;
      };

      const sendKeyboardPacket = (event, isKeyUp) => {
        if (!pointerLocked || !socket || socket.readyState !== WebSocket.OPEN) {
          return false;
        }
        const scanCode = BROWSER_CODE_TO_MAC_KEYCODE[event.code];
        if (scanCode === undefined) {
          return false;
        }
        socket.send(JSON.stringify({
          type: "keyboard_input",
          scan_code: scanCode,
          is_key_up: isKeyUp,
          modifier_keys: getModifierKeys(event),
        }));
        return true;
      };

      const queueMousePacket = () => {
        if (mouseSendQueued) {
          return;
        }
        mouseSendQueued = true;
        requestAnimationFrame(() => {
          mouseSendQueued = false;
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            pendingDeltaX = 0;
            pendingDeltaY = 0;
            return;
          }
          if (!pointerLocked && !mouseDown) {
            pendingDeltaX = 0;
            pendingDeltaY = 0;
            return;
          }
          const dxRaw = Math.trunc(pendingDeltaX);
          const dyRaw = Math.trunc(pendingDeltaY);
          const dx = Math.max(-MOUSE_MAX_DELTA_PER_PACKET, Math.min(MOUSE_MAX_DELTA_PER_PACKET, dxRaw));
          const dy = Math.max(-MOUSE_MAX_DELTA_PER_PACKET, Math.min(MOUSE_MAX_DELTA_PER_PACKET, dyRaw));
          pendingDeltaX -= dx;
          pendingDeltaY -= dy;
          const buttonStateChanged = mouseDown !== lastSentMouseDown;
          if (dx === 0 && dy === 0 && pointerLocked && !buttonStateChanged) {
            return;
          }
          lastSentMouseDown = mouseDown;
          socket.send(
            JSON.stringify({
              type: "mouse_input",
              dx,
              dy,
              mouse_down: mouseDown,
            }),
          );
        });
      };

      const updateStatus = async () => {
        const response = await fetch("/api/session/status");
        const data = await response.json();
        const active = data.active ? "active" : "idle";
        sessionStatus.textContent = `Status: ${active} (single-session, single-client)`;
        setPowerLed(Boolean(data.active));
      };

      startBtn.addEventListener("click", async () => {
        const response = await fetch("/api/session/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            owner_id: ownerId,
            boot_rom_disk: Boolean(bootRomDiskCheckbox && bootRomDiskCheckbox.checked),
          }),
        });
        const data = await response.json();
        setPowerLed(true);
        appendLog(`[session] ${data.message}`);
        updateStatus();
      });

      stopBtn.addEventListener("click", async () => {
        const response = await fetch("/api/session/stop", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ owner_id: ownerId }),
        });
        const data = await response.json();
        resetVideoState();
        clearVideoCanvas();
        setPowerLed(false);
        appendLog(`[session] ${data.message}`);
        updateStatus();
      });

      canvas.addEventListener("click", async () => {
        if (!document.pointerLockElement) {
          try {
            await canvas.requestPointerLock();
          } catch (error) {
            appendLog(`[mouse] Pointer lock failed: ${error}`);
          }
        }
      });

      canvas.addEventListener("contextmenu", (event) => {
        if (!pointerLocked) {
          return;
        }
        event.preventDefault();
        document.exitPointerLock();
      });

      document.addEventListener("pointerlockchange", () => {
        pointerLocked = document.pointerLockElement === canvas;
        if (pointerLocked) {
          virtualPointerX = WIDTH / 2;
          virtualPointerY = HEIGHT / 2;
          appendLog("[mouse] Pointer locked to video canvas (virtual pointer bounded to canvas).");
        } else {
          pendingDeltaX = 0;
          pendingDeltaY = 0;
          mouseDown = false;
          lastSentMouseDown = false;
          appendLog("[mouse] Pointer unlocked.");
          if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: "mouse_input", dx: 0, dy: 0, mouse_down: false }));
          }
        }
      });

      document.addEventListener("mousemove", (event) => {
        if (!pointerLocked) {
          return;
        }
        const scaledX = event.movementX * MOUSE_SENSITIVITY;
        const scaledY = event.movementY * MOUSE_SENSITIVITY;
        const targetX = clamp(virtualPointerX + scaledX, 0, WIDTH - 1);
        const targetY = clamp(virtualPointerY + scaledY, 0, HEIGHT - 1);
        pendingDeltaX += targetX - virtualPointerX;
        pendingDeltaY += targetY - virtualPointerY;
        virtualPointerX = targetX;
        virtualPointerY = targetY;
        queueMousePacket();
      });

      document.addEventListener("mousedown", (event) => {
        if (!pointerLocked || event.button !== 0) {
          return;
        }
        mouseDown = true;
        queueMousePacket();
      });

      document.addEventListener("mouseup", (event) => {
        if (event.button !== 0) {
          return;
        }
        mouseDown = false;
        queueMousePacket();
      });

      document.addEventListener("keydown", (event) => {
        const sent = sendKeyboardPacket(event, false);
        if (sent) {
          event.preventDefault();
        }
      });

      document.addEventListener("keyup", (event) => {
        const sent = sendKeyboardPacket(event, true);
        if (sent) {
          event.preventDefault();
        }
      });

      input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          const message = input.value.trim();
          if (message && socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: "console_input", message }));
            input.value = "";
          }
        }
      });

      const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
      const socket = new WebSocket(`${wsScheme}://${window.location.host}/ws`);
      socket.binaryType = "arraybuffer";
      socket.addEventListener("message", (event) => {
        if (event.data instanceof ArrayBuffer) {
          const buffer = event.data;
          if (buffer.byteLength < 8) {
            return;
          }
          const header = new DataView(buffer, 0, 8);
          const frameId = header.getUint16(0, true);
          const lineId = header.getUint16(2, true);
          const payloadLen = header.getUint16(4, true);
          const payloadFlags = payloadLen & RLE_FLAG;
          const payloadSize = payloadLen & LEN_MASK;
          if (lineId >= HEIGHT || payloadSize === 0) {
            return;
          }
          if (currentFrameId === null) {
            currentFrameId = frameId;
          }
          if (frameId !== currentFrameId) {
            resetFrameBuffer();
            currentFrameId = frameId;
          }
          const payload = new Uint8Array(buffer, 8, payloadSize);
          let packed = payload;
          if (payloadFlags) {
            const decoded = decodeRleLine(payload);
            if (!decoded) {
              return;
            }
            packed = decoded;
          }
          lineBuffer.set(packed, lineId * LINE_BYTES);
          if (!lineSeen[lineId]) {
            lineSeen[lineId] = 1;
            lineCount += 1;
          }
          if (lineCount >= HEIGHT) {
            renderBuffer.set(lineBuffer);
            frameReady = true;
            queueRender();
            resetFrameBuffer();
          }
          return;
        }
        const data = JSON.parse(event.data);
        if (data.message) {
          appendLog(data.message);
        }
      });
      socket.addEventListener("close", (event) => {
        resetVideoState();
        clearVideoCanvas();
        setPowerLed(false);
        const reason = event.reason ? event.reason : "n/a";
        appendLog(`[ws] Connection closed (code=${event.code}, reason=${reason}).`);
      });

      clearVideoCanvas();
      setPowerLed(false);
      updateStatus();
    </script>
  </body>
</html>
