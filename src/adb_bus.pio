; ADB bus timing skeleton derived from /opt/adb/hootswitch/firmware/bus.pio.
; RX uses edge timing sampling (host-style) while TX uses device-style drive.
; This is intentionally minimal: no protocol/state machine yet.

; ----------------------------------------------------------------------------
; RX edge sampling (adapted from hootswitch bus_rx_host)
; ----------------------------------------------------------------------------

.program adb_bus_rx

    out y, 8                    ; load max countdown from TX FIFO via autopull
    mov x, y                    ; setup for Tlt timeout
adb_rx_tlt:
    jmp x-- adb_rx_tlt_nto       ; countdown to max Tlt
    irq wait 0 rel              ; stop, inform CPU of timeout
adb_rx_tlt_nto:
    jmp pin adb_rx_tlt       [4] ; if high, continue waiting for Tlt to end

.wrap_target
    mov x, y                    ; setup countdown
adb_rx_l:
    jmp pin adb_rx_hs            ; execute jump once pin goes high
    jmp x-- adb_rx_l             ; otherwise decrement
    irq wait 0 rel               ; if we get here, timed out low
adb_rx_hs:
    in x, 8                      ; store what's left of low count
    mov x, y                     ; reload countdown for high side of bit
adb_rx_hi:
    jmp x-- adb_rx_hnt           ; skip next until we time out
    irq wait 0 rel               ; timed out, notify CPU of data phase end
adb_rx_hnt:
    jmp pin adb_rx_hi            ; loop until pin goes low again
    in x, 8                      ; pin low, on to next bit: store and loop back
.wrap

% c-sdk {
static inline void adb_bus_rx_pio_config(pio_sm_config *c,
        uint32_t offset, uint32_t pin_read)
{
    *c = adb_bus_rx_program_get_default_config(offset);
    sm_config_set_jmp_pin(c, pin_read);
    sm_config_set_in_shift(c, false, true, 8); // shift left
    sm_config_set_out_shift(c, true, true, 8); // shift right
    sm_config_set_clkdiv_int_frac(c, 50, 0); // 0.4us/clk (125 MHz base)
}
%}

; ----------------------------------------------------------------------------
; TX drive (adapted from hootswitch bus_tx_dev)
; ----------------------------------------------------------------------------

.program adb_bus_tx
.side_set 1

    set x, 26       side 0      ; delay 140us (Tlt)
adb_tx_wt:
    jmp x-- adb_tx_wt   side 0

    nop             side 1 [6]  ; '1' bit low, 35us
    nop             side 0 [12] ; '1' bit high, 65us

adb_tx_bs:
    out x, 1        side 1 [5]  ; low 30us, fetch bit value
    jmp !x adb_tx_0  side 1     ; low +5us, decide if should be released
    nop             side 0 [1]  ; release now, 10us high (line settle)
    jmp pin adb_tx_be side 0 [3]; check for collision now, +20us high
    irq 4 rel       side 0      ; if pin still low, set flag for collision
adb_tx_end:
    irq wait 0 rel  side 0      ; idle pin, stop, let CPU know xmit is done
adb_tx_0:
    nop             side 1 [5]  ; low +30us

adb_tx_be:
    jmp !osre adb_tx_bs side 0 [6] ; +35us high, loop if more data

    jmp adb_tx_end   side 1 [12] ; assert stop bit for 65us then goto end

% c-sdk {
static inline void adb_bus_tx_pio_config(pio_sm_config *c,
        uint32_t offset, uint32_t pin_write, uint32_t pin_read)
{
    *c = adb_bus_tx_program_get_default_config(offset);
    sm_config_set_sideset_pins(c, pin_write);
    sm_config_set_jmp_pin(c, pin_read);
    sm_config_set_out_shift(c, false, true, 8); // shift left (MSB first)
    sm_config_set_fifo_join(c, PIO_FIFO_JOIN_TX);
    sm_config_set_clkdiv_int_frac(c, 625, 0); // 5us/clk (125 MHz base)
}

static inline void adb_bus_tx_put(PIO pio, uint8_t sm, uint8_t v)
{
    io_rw_8 *txf = (io_rw_8 *) &(pio->txf[sm]);
    *txf = v;
}
%}
