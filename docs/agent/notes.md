# Notes

- Local reference: `/opt/MacDevDocs` contains Apple legacy Mac documentation to consult when needed for this project.
- Local reference: `/opt/Pico-SDK` and `/opt/PicoHTTPServer` are available for Pico SDK API details and Pico W captive-portal web UI patterns.
- Local reference: `/opt/SigrokPico` documents USB CDC RLE streaming patterns, and `/opt/picovga` shows a core1 video pipeline split for RP2040.
- MacDevDocs includes Macintosh Classic and Classic II developer notes; Classic lists /VSYNC and /HSYNC on the power/sweep connector and Classic II documents 512×342 internal video timing (EAGLE-generated).
- ATX `PS_ON` is driven through a ULN2803, so GPIO9 high asserts the PSU on (active-low at the ATX header).
- PIXCLK phase-lock after HSYNC (and a pre-roll high before falling-edge capture) prevents occasional 1-pixel capture phase slips.
- If HSYNC edge polarity is ever changed from the default, retune XOFF before enabling capture; otherwise the window can straddle horizontal blanking and produce a stable but incorrect black band.
- `scripts/cdc_cmd.py` is a quick helper for sending CDC command bytes and reading ASCII responses.
- Control/status traffic now uses CDC1 while CDC0 is reserved for the binary video stream; host tooling must open the second CDC interface for commands.
- Host scripts default to `/dev/serial/by-id/usb-Raspberry_Pi_EBD_IPKVM_E6614C311B855539-if00` for CDC0 and `/dev/serial/by-id/usb-Raspberry_Pi_EBD_IPKVM_E6614C311B855539-if02` for CDC1 unless overridden.
- Linux udev symlinks include `if00` (CDC0 stream) and `if02` (CDC1 control); use `/dev/serial/by-id` for stable naming.
- When `/dev/ttyACM*` numbers jump, use `udevadm info -n /dev/ttyACM2 | rg "ID_USB_INTERFACE_NUM"` to map the node to CDC0/1/2.
- `scripts/ab_capture.py` expects firmware support for the `O` command to toggle VIDEO inversion between runs.
- Classic compact Mac video timing: dot clock ~15.6672 MHz, HSYNC ~22.25 kHz (≈45 µs line), VSYNC ~60.15 Hz with ~180 µs low pulse; HSYNC continues during VSYNC and DATA idles high between active pixels.
- Classic compact Mac HSYNC and VIDEO polarity are inverted compared to TTL PC monitor expectations (VSYNC polarity matches).
- ADB implementation references: trabular (https://github.com/saybur/trabular), tashtrio (https://github.com/lampmerchant/tashtrio), adb-test-device (https://github.com/lampmerchant/adb-test-device), QuokkADB firmware (https://github.com/rabbitholecomputing/QuokkADB-firmware), HIDHopper_ADB (https://github.com/TechByAndroda/HIDHopper_ADB), adbuino (https://github.com/akuker/adbuino), adb-usb (https://github.com/gblargg/adb-usb), Apple ADB Manager PDF (https://developer.apple.com/library/archive/documentation/mac/pdf/Devices/ADB_Manager.pdf), Apple HW technote hw_01 (https://developer.apple.com/legacy/library/technotes/hw/hw_01.html#Extended).

- ADB timing reference: trabular notes that the serial handler must run roughly every 50–70 µs and defines timing windows for attention/sync/bit pulses in its ADB bus implementation.
- ADB default device addresses in trabular: keyboard=2, mouse=3; handler IDs reset alongside addresses on bus reset.
- ADB RX/TX are tied to the same shared bus; plan to filter out local TX from RX processing except when explicitly testing loopback timing.
- ADB RX now captures both low and high pulse widths; diagnostics still track low pulses, while bit decoding uses low+high pairs to align with transition-based timing.
- ADB framing uses an explicit start bit (1) and stop bit (0) per command/data frame; RX decoding should enforce these to avoid bit shifts.
- ADB RX bit decode uses a small deadband when comparing low/high pulse widths so near-equal timings are treated as invalid instead of forcing a bit value.
- Current bring-up shares the ADB bus with an existing keyboard; expect host polling and device responses to interleave with the real keyboard during diagnostics.
- ADB CDC test channel should emit a rate-limited RX-activity line when valid ADB traffic is observed, to confirm host queries are being received.
- Validate ADB behavior against the reference implementations stored in `/opt/adb` during bring-up.
- PIO timing gotcha: each PIO loop iteration can span multiple cycles (and extra setup instructions), so always convert tick counts using the loop’s actual cycles-per-iteration and document RX/TX cadence separately.
- ADB Manager (ADB_Manager.pdf) notes: default device addresses are $1–$7, with $0 reserved for the Macintosh host. Addresses $8–$E are reserved for dynamic relocation during address-resolution. During address resolution, devices respond to Talk reg3 by returning a random address in bits 8–11; the host uses Listen reg3 with handler ID $FE and a new address ($8–$E) to move a device that does not detect collision. After confirming the relocated device, the host continues resolving collisions and may move a relocated device back to its default address once the original address no longer responds. These behaviors explain why a keyboard (default $2) can be temporarily parked at address $8–$E and should respond to polls at its current address once moved. 
- ADB Manager lookup command: `pdftotext /opt/adb/miscdocs/ADB_Manager.pdf - | rg -n "address|addr|keyboard|8"`.
- ADB command bits: per ADB Manager docs and adb-usb host constants, command bits 3–2 use 0b11 for Talk and 0b10 for Listen (e.g., adb-usb uses 0x2C for Talk reg0 and 0x28 for Listen reg0 for address $2), while the legacy Flush command is encoded as low nibble 0x01. Use `/opt/adb/adb-usb/adb.h` for the 0x28/0x2C constants if needed.
- ADB bus timing guard: defer Talk replies and SRQ pulses until the bus has been idle for a short guard window (≈260 µs) after the most recent RX pulse to avoid driving in the middle of host transmissions.
- SRQ timing refinement: only arm SRQ after receiving a command byte not addressed to us, and emit the SRQ pulse within a short post-command window (≈260 µs) so SRQ stays aligned with the stop-bit timing rather than arbitrary mid-traffic asserts.
- Talk reply timing: capture the command-byte timestamp and only transmit Talk data once the nominal Tlt delay has elapsed, avoiding extra post-delay sleeps that push replies later than expected.
- ADB bring-up timing: ADB is initialized in `video_core_init()` before core1 launches, and core1 begins polling immediately in `video_core_launch()`; this keeps ADB active as soon as the firmware boots, ahead of capture start. Verified with `rg -n "adb_bus_init|video_core_launch|adb_events_init" src/main.c src/video_core.c` and `sed -n '430,520p' src/video_core.c` / `sed -n '1,140p' src/main.c`.
- SRQ arming guard: when a command byte targets our address, clear any pending SRQ arm so we don’t emit a stale SRQ pulse after completing a Talk response.
- Keyboard reg2 handling: we now track modifier-related keycodes (command/option/shift/control/caps/delete/power) in register 2 high byte (bit cleared when pressed) and accept Listen reg2 to update LED bits (low 3 bits), similar to the trablar/tashtrio behavior during bring-up.
- Talk reg0 behavior: only emit keyboard/mouse reg0 responses when data is pending (key queue entries, mouse delta/button changes) to match ADB expectations and avoid hosts continuously polling on empty reg0 replies.
- ADB reset hook: core1 resets ADB state on capture stop (and on PS_ON deassert via core bridge) so repeated boot/capture tests can be run without watchdog resets.
- SRQ arming scope: only arm SRQ on non-addressed Talk reg0 polls (not reg3 address scans) to avoid spurious SRQ pulses during host address resolution.
- Host reset detection: if the ADB bus shows a ~3.8–4.1 ms low reset pulse, reset the local ADB state so the device reverts to defaults before the subsequent Talk reg3 scan.
